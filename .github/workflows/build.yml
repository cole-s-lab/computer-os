---
name: Build images

on:
  pull_request:
    branches:
      - main
  schedule:
    - cron: '05 10 * * *'  # 10:05am UTC everyday
  push:
    branches:
      - main
    paths-ignore:
      - '**/README.md'
  workflow_dispatch:

env:
  IMAGE_DESC: "My custom image for my personal computers"
  IMAGE_KEYWORDS: "bootc,ublue,universal-blue"
  IMAGE_LOGO_URL: "https://avatars.githubusercontent.com/u/120078124?s=200&v=4"
  IMAGE_NAME: "${{ github.event.repository.name }}"
  IMAGE_REGISTRY: "ghcr.io/${{ github.repository_owner }}"
  DEFAULT_TAG: "latest"
  BIB_IMAGE: "ghcr.io/lorbuschris/bootc-image-builder:20250608"

concurrency:
  group: ${{ github.workflow }}-${{ github.ref || github.run_id }}-${{ inputs.brand_name}}-${{ inputs.stream_name }}
  cancel-in-progress: true

jobs:
  build_image:
    name: Build container image
    runs-on: ubuntu-24.04

    permissions:
      contents: read

    outputs:
      image-name: ${{ env.IMAGE_NAME }}
      registry: ${{ env.IMAGE_REGISTRY }}
      tag: ${{ env.DEFAULT_TAG }}
      tags: ${{ steps.metadata.outputs.tags }}
      labels: ${{ steps.metadata.outputs.labels }}

    steps:
      - name: Prepare environment
        run: |
          # Lowercase the image uri
          echo "IMAGE_REGISTRY=${IMAGE_REGISTRY,,}" >> ${GITHUB_ENV}
          echo "IMAGE_NAME=${IMAGE_NAME,,}" >> ${GITHUB_ENV}

      # These stage versions are pinned by https://github.com/renovatebot/renovate
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4

      # This is optional, but if you see that your builds are way too big for the runners, you can enable this by uncommenting the following lines:
      # - name: Maximize build space
      #   uses: ublue-os/remove-unwanted-software@517622d6452028f266b7ba4cc9a123b5f58a6b53 # v7
      #   with:
      #     remove-codeql: true
      
      - name: Get current date
        id: date
        run: |
          # This generates a timestamp like what is defined on the ArtifactHub documentation
          # E.G: 2022-02-08T15:38:15Z'
          echo "date=$(date -u +%Y\-%m\-%d\T%H\:%M\:%S\Z)" >> $GITHUB_OUTPUT

      # The metadata by itself is not going to do anything, you choose if you want your image to be on ArtifactHub or not.
      - name: Image Metadata
        uses: docker/metadata-action@902fa8ec7d6ecbf8d84d538b9b233a880e428804 # v5
        id: metadata
        with:
          # This generates all the tags for your image, you can add custom tags here too!
          # Default tags are "$DEFAULT_TAG" and "$DEFAULT_TAG.$date".
          tags: |
            type=raw,value=${{ env.DEFAULT_TAG }}
            type=raw,value=${{ env.DEFAULT_TAG }}.{{date 'YYYYMMDD'}}
            type=raw,value={{date 'YYYYMMDD'}}
            type=sha,enable=${{ github.event_name == 'pull_request' }}
            type=ref,event=pr
          labels: |
            io.artifacthub.package.readme-url=https://raw.githubusercontent.com/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}/refs/heads/main/README.md
            org.opencontainers.image.created=${{ steps.date.outputs.date }}
            org.opencontainers.image.description=${{ env.IMAGE_DESC }}
            org.opencontainers.image.documentation=https://raw.githubusercontent.com/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}/refs/heads/main/README.md
            org.opencontainers.image.source=https://github.com/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}/blob/main/Containerfile
            org.opencontainers.image.title=${{ env.IMAGE_NAME }}
            org.opencontainers.image.url=https://github.com/${{ github.repository_owner }}/${{ env.IMAGE_NAME }}
            org.opencontainers.image.vendor=${{ github.repository_owner }}
            org.opencontainers.image.version=${{ env.DEFAULT_TAG }}.{{date 'YYYYMMDD'}}
            io.artifacthub.package.deprecated=false
            io.artifacthub.package.keywords=${{ env.IMAGE_KEYWORDS }}
            io.artifacthub.package.license=Apache-2.0
            io.artifacthub.package.logo-url=${{ env.IMAGE_LOGO_URL }}
            io.artifacthub.package.prerelease=false
            containers.bootc=1
          sep-tags: " "
          sep-annotations: " "

      - name: Build Image
        id: build_image
        uses: redhat-actions/buildah-build@7a95fa7ee0f02d552a32753e7414641a04307056 # v2
        with:
          containerfiles: |
            ./Containerfile
          # Postfix image name with -custom to make it a little more descriptive
          # Syntax: https://docs.github.com/en/actions/learn-github-actions/expressions#format
          image: ${{ env.IMAGE_NAME }}
          tags: ${{ steps.metadata.outputs.tags }}
          labels: ${{ steps.metadata.outputs.labels }}
          oci: false

      # Rechunk is a script that we use on Universal Blue to make sure there isnt a single huge layer when your image gets published.
      # This does not make your image faster to download, just provides better resumability and fixes a few errors.
      # Documentation for Rechunk is provided on their github repository at https://github.com/hhd-dev/rechunk
      # You can enable it by uncommenting the following lines:
      - name: Run Rechunker
        id: rechunk
        uses: hhd-dev/rechunk@f153348d8100c1f504dec435460a0d7baf11a9d2 # v1.1.1
        with:
          rechunk: 'ghcr.io/hhd-dev/rechunk:v1.0.1'
          ref: "localhost/${{ env.IMAGE_NAME }}:${{ env.DEFAULT_TAG }}"
          prev-ref: "${{ env.IMAGE_REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.DEFAULT_TAG }}"
          skip_compression: true
          version: ${{ env.CENTOS_VERSION }}
          labels: ${{ steps.metadata.outputs.labels }} # Rechunk strips out all the labels during build, this needs to be reapplied here with newline separator

      # This is necessary so that the podman socket can find the rechunked image on its storage
      - name: Load in podman and tag
        run: |
          IMAGE=$(podman pull ${{ steps.rechunk.outputs.ref }})
          sudo rm -rf ${{ steps.rechunk.outputs.output }}
          for tag in ${{ steps.metadata.outputs.tags }}; do
            podman tag $IMAGE ${{ env.IMAGE_NAME }}:$tag
          done

  push_image:
    name: Push container image
    needs: build_image
    runs-on: ubuntu-24.04
    if: github.event_name != 'pull_request' && github.ref == format('refs/heads/{0}', github.event.repository.default_branch)

    permissions:
      contents: read
      packages: write
      id-token: write

    outputs:
      digest: ${{ steps.push.outputs.digest }}

    steps:
      - name: Prepare environment
        run: |
          # Lowercase the image uri
          echo "IMAGE_REGISTRY=${IMAGE_REGISTRY,,}" >> ${GITHUB_ENV}
          echo "IMAGE_NAME=${IMAGE_NAME,,}" >> ${GITHUB_ENV}

      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4

      # Download the built image from the previous job
      - name: Download built image
        run: |
          # Pull the image that was built in the previous job
          # Note: This assumes the image is available in the runner's local storage
          # In practice, you might need to use a registry or artifact transfer
          echo "Image will be available from previous job's podman storage"

      # These `if` statements are so that pull requests for your custom images do not make it publish any packages under your name without you knowing
      # They also check if the runner is on the default branch so that things like the merge queue (if you enable it), are going to work
      - name: Login to GitHub Container Registry
        uses: docker/login-action@74a5d142397b4f367a81961eba4e8cd7edddf772 # v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Push To GHCR
        uses: redhat-actions/push-to-registry@5ed88d269cf581ea9ef6dd6806d01562096bee9c # v2
        id: push
        env:
          REGISTRY_USER: ${{ github.actor }}
          REGISTRY_PASSWORD: ${{ github.token }}
        with:
          registry: ${{ needs.build_image.outputs.registry }}
          image: ${{ needs.build_image.outputs.image-name }}
          tags: ${{ needs.build_image.outputs.tags }}
          username: ${{ env.REGISTRY_USER }}
          password: ${{ env.REGISTRY_PASSWORD }}

      # This section is optional and only needs to be enabled if you plan on distributing
      # your project for others to consume. You will need to create a public and private key
      # using Cosign and save the private key as a repository secret in Github for this workflow
      # to consume. For more details, review the image signing section of the README.
      - name: Install Cosign
        uses: sigstore/cosign-installer@fb28c2b6339dcd94da6e4cbcbc5e888961f6f8c3 # v3.9.0

      - name: Sign container image
        run: |
          IMAGE_FULL="${{ needs.build_image.outputs.registry }}/${{ needs.build_image.outputs.image-name }}"
          for tag in ${{ needs.build_image.outputs.tags }}; do
            cosign sign -y --key env://COSIGN_PRIVATE_KEY $IMAGE_FULL:$tag
          done
        env:
          TAGS: ${{ steps.push.outputs.digest }}
          COSIGN_EXPERIMENTAL: false
          COSIGN_PRIVATE_KEY: ${{ secrets.SIGNING_SECRET }}

      - name: Generate SBOM
        uses: anchore/sbom-action@61119d458adab75f756bc0b9e4bde25725f86a7a # v0.17.2
        with:
          image: ${{ needs.build_image.outputs.registry }}/${{ needs.build_image.outputs.image-name }}:${{ needs.build_image.outputs.tag }}
          format: spdx-json
          output-file: sbom.spdx.json

      - name: Upload SBOM
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: sbom-${{ github.run_number }}
          path: sbom.spdx.json
          retention-days: 30

  build_qcow2:
    name: Build QCOW2 disk image
    needs: push_image
    runs-on: ubuntu-24.04
    timeout-minutes: 60

    permissions:
      contents: read
      packages: read
      id-token: write

    steps:
      - name: Prepare environment
        run: |
          USER_UID=$(id -u)
          USER_GID=$(id -g)
          echo "USER_UID=${USER_UID}" >> ${GITHUB_ENV}
          echo "USER_GID=${USER_GID}" >> ${GITHUB_ENV}

      - name: Debug environment
        run: |
          echo "Image: ${{ needs.build_image.outputs.registry }}/${{ needs.build_image.outputs.image-name }}:${{ needs.build_image.outputs.tag }}"
          echo "Disk type: qcow2"
          echo "Config file: ./disk_config/disk.toml"

      - name: Maximize build space
        uses: ublue-os/remove-unwanted-software@cc0becac701cf642c8f0a6613bbdaf5dc36b259e # v9
        with:
          remove-codeql: true

      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4

      - name: Build QCOW2 disk image
        id: build
        uses: osbuild/bootc-image-builder-action@main
        with:
          builder-image: ${{ env.BIB_IMAGE }}
          config-file: ./disk_config/disk.toml
          image: ${{ needs.build_image.outputs.registry }}/${{ needs.build_image.outputs.image-name }}:${{ needs.build_image.outputs.tag }}
          chown: ${{ env.USER_UID }}:${{ env.USER_GID }}
          types: qcow2
          additional-args: --use-librepo=True

      - name: Upload QCOW2 disk image and Checksum to Job Artifacts
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: disk-image-qcow2-${{ github.run_number }}
          path: ${{ steps.build.outputs.output-directory }}
          if-no-files-found: error
          retention-days: 7
          compression-level: 6
          overwrite: true

  build_anaconda_iso:
    name: Build Anaconda ISO
    needs: push_image
    runs-on: ubuntu-24.04
    timeout-minutes: 120

    permissions:
      contents: read
      packages: read
      id-token: write

    steps:
      - name: Prepare environment
        run: |
          USER_UID=$(id -u)
          USER_GID=$(id -g)
          echo "USER_UID=${USER_UID}" >> ${GITHUB_ENV}
          echo "USER_GID=${USER_GID}" >> ${GITHUB_ENV}

      - name: Debug environment
        run: |
          echo "Image: ${{ needs.build_image.outputs.registry }}/${{ needs.build_image.outputs.image-name }}:${{ needs.build_image.outputs.tag }}"
          echo "Disk type: anaconda-iso"
          echo "Config file: ./disk_config/iso.toml"

      - name: Maximize build space
        uses: ublue-os/remove-unwanted-software@cc0becac701cf642c8f0a6613bbdaf5dc36b259e # v9
        with:
          remove-codeql: true

      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4

      - name: Build Anaconda ISO
        id: build
        uses: osbuild/bootc-image-builder-action@main
        with:
          builder-image: ${{ env.BIB_IMAGE }}
          config-file: ./disk_config/iso.toml
          image: ${{ needs.build_image.outputs.registry }}/${{ needs.build_image.outputs.image-name }}:${{ needs.build_image.outputs.tag }}
          chown: ${{ env.USER_UID }}:${{ env.USER_GID }}
          types: anaconda-iso
          additional-args: --use-librepo=True

      - name: Upload Anaconda ISO and Checksum to Job Artifacts
        uses: actions/upload-artifact@ea165f8d65b6e75b540449e92b4886f43607fa02 # v4
        with:
          name: disk-image-anaconda-iso-${{ github.run_number }}
          path: ${{ steps.build.outputs.output-directory }}
          if-no-files-found: error
          retention-days: 7
          compression-level: 6
          overwrite: true

  summary:
    name: Build Summary
    runs-on: ubuntu-24.04
    needs: [build_image, push_image, build_qcow2, build_anaconda_iso]
    if: always()

    steps:
      - name: Build Summary
        run: |
          echo "## Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Component | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Container Build | ${{ needs.build_image.result == 'success' && '✅ Success' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Container Push | ${{ needs.push_image.result == 'success' && '✅ Success' || needs.push_image.result == 'skipped' && '⏭️ Skipped' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| QCOW2 Disk | ${{ needs.build_qcow2.result == 'success' && '✅ Success' || needs.build_qcow2.result == 'skipped' && '⏭️ Skipped' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Anaconda ISO | ${{ needs.build_anaconda_iso.result == 'success' && '✅ Success' || needs.build_anaconda_iso.result == 'skipped' && '⏭️ Skipped' || '❌ Failed' }} |" >> $GITHUB_STEP_SUMMARY
